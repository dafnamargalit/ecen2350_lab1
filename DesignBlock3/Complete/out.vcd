$date
	Mon Oct  7 09:57:09 2019
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module tb $end
$var wire 10 ! LEDR [9:0] $end
$var wire 8 " HEX5 [7:0] $end
$var wire 8 # HEX4 [7:0] $end
$var wire 8 $ HEX1 [7:0] $end
$var wire 8 % HEX0 [7:0] $end
$var reg 10 & SW [9:0] $end
$scope module DUT $end
$var wire 10 ' SW [9:0] $end
$var wire 1 ( twosComp $end
$var wire 4 ) sign2 [3:0] $end
$var wire 4 * sign1 [3:0] $end
$var wire 4 + input2 [3:0] $end
$var wire 4 , input1 [3:0] $end
$var wire 4 - abs2 [3:0] $end
$var wire 4 . abs1 [3:0] $end
$var wire 10 / LEDR [9:0] $end
$var wire 8 0 HEX5 [7:0] $end
$var wire 8 1 HEX4 [7:0] $end
$var wire 8 2 HEX1 [7:0] $end
$var wire 8 3 HEX0 [7:0] $end
$scope module inputSign1 $end
$var wire 8 4 HEX [7:0] $end
$var wire 4 5 NUM [3:0] $end
$var reg 8 6 out [7:0] $end
$upscope $end
$scope module inputSign2 $end
$var wire 8 7 HEX [7:0] $end
$var wire 4 8 NUM [3:0] $end
$var reg 8 9 out [7:0] $end
$upscope $end
$scope module inputVal1 $end
$var wire 8 : HEX [7:0] $end
$var wire 4 ; NUM [3:0] $end
$var reg 8 < out [7:0] $end
$upscope $end
$scope module inputVal2 $end
$var wire 8 = HEX [7:0] $end
$var wire 4 > NUM [3:0] $end
$var reg 8 ? out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10010010 ?
b101 >
b10010010 =
b10010010 <
b101 ;
b10010010 :
b10001000 9
b1010 8
b10001000 7
b10001000 6
b1010 5
b10001000 4
b10010010 3
b10001000 2
b10010010 1
b10001000 0
bz100 /
b101 .
b101 -
b1011 ,
b1011 +
b1010 *
b1010 )
1(
b1110111011 '
b1110111011 &
b10010010 %
b10001000 $
b10010010 #
b10001000 "
bz100 !
$end
#100
b10000011 "
b10000011 0
b10000011 4
b10000011 6
b10000011 $
b10000011 2
b10000011 7
b10000011 9
b10011001 #
b10011001 1
b10011001 :
b10011001 <
b10011001 %
b10011001 3
b10011001 =
b10011001 ?
b1011 *
b1011 5
b1011 )
b1011 8
b100 .
b100 ;
b100 -
b100 >
0(
b100 ,
b100 +
b1000100 &
b1000100 '
#400
b10001000 %
b10001000 3
b10001000 =
b10001000 ?
bz001 !
bz001 /
b1010 -
b1010 >
b1010 +
b1001001010 &
b1001001010 '
#1400
